# 选择题

## 1. 如何根据先序中序求后序。

+ 1）先序序列最中间一个元素为根结点，将线性表分为两部分（即二叉树的左右子树），再用中序去分别处理两个部分(即判断左右)。2）对每个部分再执行1），直到剩余一个结点。
+ 1)中序序列第一个元素为根结点，将线性表分为两部分（即二叉树的左右子树），再用先序去分别处理两个部分(即判断左右)。2）对每个部分再执行1），直到剩余一个结点。
+ 1)先序序列第一个元素为根结点，将线性表分为两部分（即二叉树的左右子树），再用中序去分别处理两个部分(即判断左右)。2）对每个部分再执行1），直到剩余一个结点。(√)

## 2. 用深度优先遍历方法遍历一个有向无环图，并在深度优先遍历算法中按退栈次序打印出相应的顶点，则输出的顶点序列是（）。

`答案：` 逆拓扑排序

+ 其实树（无环图相当于树）深度优先遍历就是拓扑排序，“按退栈次序打印出相应的顶点”就是逆拓扑的。
+ DFS递归内部，输出代码写在内部DFS下一行，就是逆拓扑，写在DFS前面一行就是拓扑，不过拓扑一般都用BFS写的吧。。没用DFS写过

## 3.请问下面哪种方式可以在不改变原来数组的情况下，拷贝出数组 b ，且满足 b!=a 。例如数组 a 为 [1,2,3] 。

+ let b=a;
+ let b=a.slice();
+ let b=a.splice(0,0);
+ let b=a.concat();  (√)

## 4.把一棵树转换为二叉树后，这棵二叉树的形态是（）

+ 唯一的 (√)
+ 有多种
+ 有多种，根结点没有左孩子
+ 有多种，根结点没有右孩子

![image.png](https://upload-images.jianshu.io/upload_images/9140378-35ac0331c93981ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

## 5.在下列几种排序方法中，空间复杂度最高的是（）

+ 归并排序 (√)
+ 快速排序
+ 插入排序
+ 选择排序

`解析：`

+ 归并排序空间复杂度为O（n）
+ 快速排序：
  + 就地快排空间复杂度为O（1） 
    + 使用递归：
      + 每一次都平分数组，即最优情况是O（logn）
      + 退化为冒泡排序，即最差情况是O（n）
+ 插入和选择都是O（1）

## 6.设顺序表的长度为 n 。下列排序方法中，最坏情况下比较次数小于 n(n-1)/2 的是（ ）

+ 堆排序 (√)
+ 快速排序
+ 简单插入排序
+ 冒泡排序

`解析：`堆排序最坏情况下比较次数为 O(nlog2n) ，快速排序、简单插入排序、冒泡排序最坏情况下比较次数为 n(n-1)/2