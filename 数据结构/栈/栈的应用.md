# 栈的应用 -- 括号匹配

## 主要的代码

```c
int match_kouhao(char c[])
{
    int i = 0;
    sequence_stack s;
    init(&s);
    while(c[i] != '#')
    {
        switch(c[i])
        {
            case '{':
            case '[':
            case '(': 
                push(&s,c[i]); //进栈
                break;
            case '}': 
                if(!empty(s) && read(s) == '{')
                {
                    pop(&s);  ///出栈
                    break;
                }
                else
                    return 0;
            case ']':
                if(!empty(s) && read(s) == '[')
                {
                    pop(&s);
                    break;
                }
                else
                    return 0;
            case ')':
                if(!empty(s) && read(s) == '(')
                {
                    pop(&s);
                    break;
                }
                else
                    return 0;
        }
        i ++;
    }
    return (empty(s));
}
```

+ ## [整体代码](https://github.com/wanghao15536870732/StudyNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%20--%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.cpp)

## 结果演示：

![091$D4N)EK7`YBQ~8GBJKJD.png](https://upload-images.jianshu.io/upload_images/9140378-9417e716f0973f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

# 中缀、后缀表达式

+ 3 + 4) × 5 / 6 中缀表达式
+ 3 4 + 5 × 6 / 后缀表达式

## 后缀表达式（后缀记法、逆波兰式）

+ 后缀表达式与前缀表达式类似，只是运算符位于操作数之后。

## 后缀表达式的计算机求值：

### 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。例如后缀表达式“3 4 + 5 × 6 -”：

+ (1) 从左至右扫描，将3和4压入堆栈；
+ (2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；
+ (3) 将5入栈；
+ (4) 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
+ (5) 将6入栈；
+ (6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。

## 将中缀表达式转换为后缀表达式：

+ (1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；
+ (2) 从左至右扫描中缀表达式；
+ (3) 遇到操作数时，将其压入S2；
+ (4) 遇到运算符时，比较其与S1栈顶运算符的优先级：
+ (4-1) 如果S1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
+ (4-2) 否则，若优先级比栈顶运算符的高，也将运算符压入S1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）
+ (4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；
+ (5) 遇到括号时：
+ (5-1) 如果是左括号“(”，则直接压入S1；
+ (5-2) 如果是右括号“)”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到左括号为止，此时将这一对括号丢弃；
+ (6) 重复步骤(2)至(5)，直到表达式的最右边；
+ (7) 将S1中剩余的运算符依次弹出并压入S2；
+ (8) 依次弹出S2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）

## 例如，将中缀表达式 a * (b + c) - d 转换为后缀表达式的过程如下：

|||||
|:--|:--|:--|:--|
|扫描到的元素|S2(栈底->栈顶)|S1 (栈底->栈顶)|说明|
|a|a||操作符压入s2|
|*|a|*|运算符压入s1|
|(|a|* (| ' ( ' 优先级比 ' * ' 高,直接将该运算符压入s1|
|b|a b|* (| 操作符压入s2|
|+|a b | * ( + |s2 栈顶元素为 ' ( ' 直接入栈|
|c|a b c | * ( +| 操作符压入 s1 栈|
|)|a b c + | * | 与 s2 栈中元素 ' ( ' 匹配，将 ' + ' 弹出压入s1,匹配好的括号直接出栈 |
|-| a b c + * | - | ' - ' 运算符优先级低于 ' * '，将 ' * ' 弹出 s1 ,压入 s2  ，' - ' 压入 s1|
|d|a b c + * d | -| 操作符压入 栈 s1 |
||a b c + * d -||最后将 s2 所有元素弹出压入 s1|

+ ## 结果为 a b c + * d -

## 具体代码实现

```c
/****************************************/
/****** 判断一个字符串是否为运算符 ******/
/****************************************/
int is_operation(char op)
{
    switch(op)
    {
        case '+':
        case '-':
        case '*':
        case '-/': return 1;
        default:return 0;
    }
}
```

```c

/****************************************/
/*********** 求运算符的优先级 ***********/
/****************************************/
int priority(char op)
{
    switch(op)
    {
        case '#': return -1;
      case '(': return 0;
      case '+': 
        case '-': return 1;
        case '*':
        case '/': return 2;
        default: return -1;
    }
}
```

```c

/***************************************************/
/* 将一个中缀表达式 e 转换成与它等价的后缀表达式 f */
/***************************************************/

void postfix(char e[],char f[])
{
    int i = 0,j = 0;
    char opst[100];
    int top,t;
    top = 0;
    opst[top] = '#'; 
    top ++;
    while(e[i])
    {
        if((e[i] >= '0' && e[i] <= '9') || e[i] == '.')
            f[j ++] = e[i];  // 遇到数字或者小鼠点直接写入后缀表达式
        else if( e[i] == '(')  // 遇到左括号进入操作符栈
        {
            opst[top] == e[i]; 
            top ++;
        }
        else if(e[i] == ')')
            //遇到右括号将其对应的左括号后的操作符全部写入后缀表达式 
        {
            t = top - 1;
            while(opst[t] != '(')
            {
                f[j ++] = opst[-- top];
                t = top - 1;
            }
            top --; // '( ' 出栈
        }
        else if(is_operation(e[i])) // '+ 、-、*、/ '
        {
            f[j ++] = ' '; // 用空格分开两个操作符
            while(priority(opst[top - 1]) >= priority(e[i]))
                f[j ++] = opst[-- top];
            opst[top] = e[i];
            top ++;// 当前元素入栈
        }
        i ++;// 处理下一个元素
    }
    while(top)
        f[j ++] = opst[-- top];
}
```

+ ## [具体代码](https://github.com/wanghao15536870732/StudyNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.cpp)

### 写的有点仓促，难免会有一些小差错，如有任何错误，欢迎指正，谢谢！