# 插入排序

## （一）概念及其实现

`百度百科`

> **插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常要从后向前扫描，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间**

假设待排序的7个数字为{312，126，272，226，28，165，123}，直接插入排序算法的执行过程为

> 一般来说，插入排序都采用在线性表上实现。具体算法描述如下：

+ 从第一个元素开始，该元素可以认为已经被排序
+ 取出下一个元素，在已经排序的元素序列中从后向前扫描
+ 如果该元素（已排序）大于新元素，将该元素移到下一位置
+ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位
+ 将新元素插入到该位置后
+ 重复步骤2~5

|次序|哨兵|排序码|
|:--:|:--:|:--|
|||[]，312，126，272，226，28，165，123|
|初始|( )|[312]，126，272，226，28，165，123|
|i = 2|(126)|[126，312]，272，226，28，165，123|
|i = 3|(272)|[126，272，312]，226，28，165，123|
|i = 4|(226)|[126，226，172，312]，28，165，123|
|i = 5|(28)|[28，126，226，172，312]，165，123|
|i = 6|(165)|[28，126，165，226，172，312]，123|
|i = 7|(123)|[28，123，126，165，226，172，312]|

## 代码：

```c
//简单插入排序
void insertsort(table *tab)
{
    int i, j;
    for (i = 1; i <= tab->length; i++)  //依次插入从第2个开始的而所有元素
    {
        j = i - 1;
        tab->r[0] = tab->r[i];  //设置哨兵，准备找插入位置
        while (tab->r[0] < tab->r[j])   //比较当前结点与哨兵的大小
        {
            tab->r[j + 1] = tab->r[j];  //讲大于的数字向后移动
            j = j - 1;  //继续向左查找
        }
        tab->r[j + 1] = tab->r[0];  //最后i插入第i个数据的副本，即前面设置的哨兵
    }
}
```

## (二)算法复杂度

### 1.时间复杂度：O(n^2)

直接插入排序耗时的操作有：比较+后移赋值。时间复杂度如下：

+ 1)最好情况：序列是升序排列，在这种情况下，需要进行的比较操作需（n-1）次。后移赋值操作为0次。即O(n)
+ 2)最坏情况：序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。后移赋值操作是比较操作的次数加上 (n-1）次。即O(n^2)
+ 3)渐进时间复杂度（平均时间复杂度）：O(n^2)

### 2.空间复杂度：O(1)

+ 从实现原理可知，直接插入排序是在原输入数组上进行后移赋值操作的（称“就地排序”），所需开辟的辅助空间跟输入数组规模无关，所以空间复杂度为：O(1)

## (三)稳定性

直接插入排序是稳定的，不会改变相同元素的相对顺序。

## (四)与冒泡排序复杂度对比

|冒泡排序|直接插入排序|
|:--:|:--:|
|![Bubble_sort_animation.gif](https://upload-images.jianshu.io/upload_images/9140378-6bb587e72caf5277.gif?imageMogr2/auto-orient/strip)|![InsertSort.gif](https://upload-images.jianshu.io/upload_images/9140378-0628c2a1468fabb5.gif?imageMogr2/auto-orient/strip)|